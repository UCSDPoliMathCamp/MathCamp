{
  "hash": "d4d3aa993c917ad40588b8285c3ebfee",
  "result": {
    "markdown": "\n# Data Wrangling and Cleaning {#datawrangling}\n\n## Clean Data\n\nThe raw data used in much of political science research rarely comes to us in a format that is immediately accessible for analysis. Instead, we frequently need to write an R script to \"clean\" the data first. Only after cleaning the data will it be usable for visualization or statistical modeling. This process (also known as \"data wrangling\") can be extremely arduous and time-consuming---depending on how messy the raw data is in the first place. According to the common aphorism, the time you spend writing R code to clean your data sets will far exceed the time you spend subsequently running any sort of statistical analysis on the cleaned data.\n\nAlthough data cleaning has a reputation as a dull, menial task (compared to the \"fun\" of statistical modeling), try to avoid treating the process like it is merely a roadblock---something to be overcome before you can begin the *real* analysis. In fact, each decision you make when wrangling your raw data into its final state [is a crucial part of the final research product](https://counting.substack.com/p/data-cleaning-is-analysis-not-grunt#:~:text=The%20act%20of%20cleaning%20data%20is%20the%20act%20of%20preferentially,the%20act%20of%20data%20analysis.). Whether or not to drop certain observations, or using different levels of data aggregation are some examples of choices which can have massive downstream effects. You should be thoughtful and transparent about your decision-making process the whole time you spend cleaning data.\n\n## Cleaning Data Using dplyr\n\nAs in the other sections of this book, we will be using the Tidyverse approach to data cleaning here. The Tidyverse package for data cleaning is [dplyr](https://dplyr.tidyverse.org/) and it contains most of the functions we will be using in this chapter.\n\nRather than downloading a .csv file and using the `read_csv()` function to load in our data for this chapter, we will be using a package which contains multiple data sets. The data come from the [United Nations General Assembly](https://github.com/dgrtwo/unvotes). First install the unvotes package by running the following command in your Console.\n\n\n::: {.cell hash='13_data_wrangling_cleaning_cache/html/unnamed-chunk-1_db8b492b5dd60ca6c6050e6adccb0d11'}\n\n```{.r .cell-code}\ninstall.packages(\"unvotes\")\n```\n:::\n\n\nThen run\n\n\n::: {.cell hash='13_data_wrangling_cleaning_cache/html/unnamed-chunk-2_a8306d550bae2ca1022ae119d28d49fc'}\n\n```{.r .cell-code}\nlibrary(unvotes)\nlibrary(tidyverse)\n```\n:::\n\n\nWhen you use the `library()` function, many packages automatically load small data sets that immediately become available for use. However, accessing these data can be a bit confusing because they do not automatically show up as objects in your Environment tab. Let's add the unvotes data sets to our Environment with the following chunk of code:\n\n\n::: {.cell hash='13_data_wrangling_cleaning_cache/html/unnamed-chunk-3_1f3ff9feaa5c578c8c0bc95ff51484bd'}\n\n```{.r .cell-code}\nun_votes <- un_votes\nun_roll_calls <- un_roll_calls\nun_roll_call_issues <- un_roll_call_issues\n```\n:::\n\n\n-   `un_votes`, country-vote level data. Each row is a country's vote on a particular UN Assembly resolution.\n-   `un_roll_calls`, resolution level data. Contains information about each resolution.\n-   `un_roll_call_issues`, resolution level data. Contains the issue-area for each resolution.\n\n### The Pipe Operator\n\nBefore we get started using dplyr we need to first introduce the \"pipe\" operator `|>`. Pipes are an extremely convenient tool for linking sequences of functions together. They work by passing the object on the left hand side of the pipe into the function following the pipe. [Here is an example](https://twitter.com/andrewheiss/status/1359583543509348356).\n\n\n::: {.cell hash='13_data_wrangling_cleaning_cache/html/unnamed-chunk-4_6f5e551ce2ae2924c20b9cf442092172'}\n\n```{.r .cell-code}\n# The pipe way\nme |> \n  wake_up(time = \"8:00\") |> \n  get_out_of_bed(side = \"correct\") |> \n  get_dressed(pants = TRUE, shirt = TRUE) |> \n  leave_house(car = FALSE, bike = TRUE)\n\n# The non-pipe way\nleave_house(get_dressed(get_out_of_bed(wake_up(me, time = \"8:00\"), side = \"correct\"), pants = TRUE, shirt = TRUE), car = FALSE, bike = TRUE)\n```\n:::\n\n\nBoth code chunks above will end up doing the same thing. But the pipe method is much easier to write, and much easier for others to read and understand. \n\nBefore R version 4.1, the pipe operator was only available in the [magrittr](https://magrittr.tidyverse.org/) package (which remains part of the Tidyverse). The magrittr pipe is written `%>%` and many R users continue to use this over the native R `|>`. There are a few very minor differences between the two pipes, which you should feel free to ignore. We use the native R `|>` pipe in this book because it is generally a good idea, all else equal, to reduce your dependency on outside packages when writing code. \n\n## Working with Columns\n\nEach column in a data set typically represents a single variable, or attribute, relating to the observation in a particular row. In this section we will look at some of dplyr's functions for working with columns.\n\n### Select\n\nThe `select()` function is primarily used to remove unwanted columns from the data. Here is an example.\n\n\n::: {.cell hash='13_data_wrangling_cleaning_cache/html/unnamed-chunk-5_30b70f7fb43694a1b8a2919d6b4f7510'}\n\n```{.r .cell-code}\nun_roll_calls |> \n  select(rcid, date) |> # Keeping only two variables\n  head() # Print out first 6 rows\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 2\n   rcid date      \n  <int> <date>    \n1     3 1946-01-01\n2     4 1946-01-02\n3     5 1946-01-04\n4     6 1946-01-04\n5     7 1946-01-02\n6     8 1946-01-05\n```\n:::\n:::\n\n\nThe `head()` function prints out the first few rows of a data set, and can be helpful to check if your cleaning function worked in the way you expected.\n\nNote that the code chunk above did not alter the data set object `un_roll_calls`. If we wanted to take this smaller data set and use it for something else, we will need to use the assignment operator `<-` to save our work.\n\n\n::: {.cell hash='13_data_wrangling_cleaning_cache/html/unnamed-chunk-6_c57bda7813b9b818a49915806aa917c5'}\n\n```{.r .cell-code}\n# This creates a new object called \"small_un_roll_calls\"\n# containing only rcid and date columns\nsmall_un_roll_calls <- un_roll_calls |> \n  select(rcid, date)\n```\n:::\n\n\nThe `select()` function can be very versatile. Rather than typing every column name we want to keep, it is often faster to specify the columns we want to drop.\n\n\n::: {.cell hash='13_data_wrangling_cleaning_cache/html/unnamed-chunk-7_6e39f5f3d6098c942b5b65d8296a15f5'}\n\n```{.r .cell-code}\nun_roll_calls |> \n  select(-session) |> # Keep everything except session column\n  head()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 8\n   rcid importantvote date       unres   amend  para short                 descr\n  <int>         <int> <date>     <chr>   <int> <int> <chr>                 <chr>\n1     3             0 1946-01-01 R/1/66      1     0 AMENDMENTS, RULES OF… \"TO …\n2     4             0 1946-01-02 R/1/79      0     0 SECURITY COUNCIL ELE… \"TO …\n3     5             0 1946-01-04 R/1/98      0     0 VOTING PROCEDURE      \"TO …\n4     6             0 1946-01-04 R/1/107     0     0 DECLARATION OF HUMAN… \"TO …\n5     7             0 1946-01-02 R/1/295     1     0 GENERAL ASSEMBLY ELE… \"TO …\n6     8             0 1946-01-05 R/1/297     1     0 ECOSOC POWERS         \"TO …\n```\n:::\n:::\n\n\nThere are many other convenient ways to selection columns (e.g. by common names, by type of data, or by position in the data set). For a full list of ways to use `select()` see [this link](https://dplyr.tidyverse.org/reference/select.html). Here is one example of selecting every column which is a \"character\" type.\n\n\n::: {.cell hash='13_data_wrangling_cleaning_cache/html/unnamed-chunk-8_fd693f58df64deb26afa0ff697a6d648'}\n\n```{.r .cell-code}\nun_roll_calls |> \n  select(where(is.character)) |> \n  head()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 3\n  unres   short                          descr                                  \n  <chr>   <chr>                          <chr>                                  \n1 R/1/66  AMENDMENTS, RULES OF PROCEDURE \"TO ADOPT A CUBAN AMENDMENT TO THE UK …\n2 R/1/79  SECURITY COUNCIL ELECTIONS     \"TO ADOPT A USSR PROPOSAL ADJOURNING D…\n3 R/1/98  VOTING PROCEDURE               \"TO ADOPT THE KOREAN PROPOSAL THAT INV…\n4 R/1/107 DECLARATION OF HUMAN RIGHTS    \"TO ADOPT A CUBAN PROPOSAL (A/3-C) THA…\n5 R/1/295 GENERAL ASSEMBLY ELECTIONS     \"TO ADOPT A 6TH COMMITTEE AMENDMENT (A…\n6 R/1/297 ECOSOC POWERS                  \"TO ADOPT A SECOND 6TH COMM. AMENDMENT…\n```\n:::\n:::\n\n\nLastly, we can use `select()` to rename columns in our data. The chunk of code below selects the \"unres\" and date columns, and renames \"unres\" to \"un_resolution\" at the same time.\n\n\n::: {.cell hash='13_data_wrangling_cleaning_cache/html/unnamed-chunk-9_c428470736256611c09ee77491524a7f'}\n\n```{.r .cell-code}\nun_roll_calls |> \n  select(un_resolution = unres, date) |> \n  head()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 2\n  un_resolution date      \n  <chr>         <date>    \n1 R/1/66        1946-01-01\n2 R/1/79        1946-01-02\n3 R/1/98        1946-01-04\n4 R/1/107       1946-01-04\n5 R/1/295       1946-01-02\n6 R/1/297       1946-01-05\n```\n:::\n:::\n\n\nIf you only want to rename columns---without specifying which to select---dplyr has a function `rename()` for this purpose. The syntax is similar to the code chunk above `new_variable_name = original_variable_name`. This code will keep all columns and change the names of the specified variables.\n\n\n::: {.cell hash='13_data_wrangling_cleaning_cache/html/unnamed-chunk-10_61812b01aa8f8290b27183ad554be767'}\n\n```{.r .cell-code}\nun_roll_calls |> \n  rename(un_resolution = unres,\n         amendment = amend,\n         paragraph = para) |> \n  head()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 9\n   rcid session importantvote date       un_resolu…¹ amend…² parag…³ short descr\n  <int>   <dbl>         <int> <date>     <chr>         <int>   <int> <chr> <chr>\n1     3       1             0 1946-01-01 R/1/66            1       0 AMEN… \"TO …\n2     4       1             0 1946-01-02 R/1/79            0       0 SECU… \"TO …\n3     5       1             0 1946-01-04 R/1/98            0       0 VOTI… \"TO …\n4     6       1             0 1946-01-04 R/1/107           0       0 DECL… \"TO …\n5     7       1             0 1946-01-02 R/1/295           1       0 GENE… \"TO …\n6     8       1             0 1946-01-05 R/1/297           1       0 ECOS… \"TO …\n# … with abbreviated variable names ¹​un_resolution, ²​amendment, ³​paragraph\n```\n:::\n:::\n\n\n### Mutate\n\nThe `select()` and `rename()` functions are great for tidying up your data sets, but they do not change the underlying variables. To change existing variables or to create new ones we use `mutate()`.\n\nLet's say we discovered that all the roll call IDs in the column \"rcid\" were supposed to be in multiples of 10. The code chunk below creates a new variable called \"rcid_10\" which is simply the value of the original \"rcid\" variable multiplied by 10.\n\n\n::: {.cell hash='13_data_wrangling_cleaning_cache/html/unnamed-chunk-11_e8f4b6100df9ec2252779bbbfc479f2b'}\n\n```{.r .cell-code}\nun_votes |> \n  mutate(rcid_10 = rcid * 10) |> \n  head()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 5\n   rcid country            country_code vote  rcid_10\n  <dbl> <chr>              <chr>        <fct>   <dbl>\n1     3 United States      US           yes        30\n2     3 Canada             CA           no         30\n3     3 Cuba               CU           yes        30\n4     3 Haiti              HT           yes        30\n5     3 Dominican Republic DO           yes        30\n6     3 Mexico             MX           yes        30\n```\n:::\n:::\n\n\nIf you didn't want to create a brand new variable, and instead wanted to overwrite the original variable, you just need to put the original variable to the left of the `=` in `mutate()`.\n\n\n::: {.cell hash='13_data_wrangling_cleaning_cache/html/unnamed-chunk-12_d13b0fe9846afb7bae6001c223308fad'}\n\n```{.r .cell-code}\nun_votes |> \n  mutate(rcid = rcid * 10) |> \n  head()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 4\n   rcid country            country_code vote \n  <dbl> <chr>              <chr>        <fct>\n1    30 United States      US           yes  \n2    30 Canada             CA           no   \n3    30 Cuba               CU           yes  \n4    30 Haiti              HT           yes  \n5    30 Dominican Republic DO           yes  \n6    30 Mexico             MX           yes  \n```\n:::\n:::\n\n\nWe commonly need to create a new variable whose values depend on the values of one of the original variables. The function `case_when()` helps us do this inside `mutate()`.\n\n\n::: {.cell hash='13_data_wrangling_cleaning_cache/html/unnamed-chunk-13_584f38c0aa4251238d5141bb9c0c042d'}\n\n```{.r .cell-code}\nun_votes |> \n  mutate(vote_dummy = case_when(vote == \"yes\" ~ 1,\n                                vote == \"no\" ~ 0)) |> \n  head()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 5\n   rcid country            country_code vote  vote_dummy\n  <dbl> <chr>              <chr>        <fct>      <dbl>\n1     3 United States      US           yes            1\n2     3 Canada             CA           no             0\n3     3 Cuba               CU           yes            1\n4     3 Haiti              HT           yes            1\n5     3 Dominican Republic DO           yes            1\n6     3 Mexico             MX           yes            1\n```\n:::\n:::\n\n\nAs you can see, the code chunk above creates a new variable called \"vote_dummy\" which takes the value `1` if \"vote\" equals `\"yes\"` and takes the values `0` if \"vote\" equals `\"no\"`. Like other programming languages, R uses the `==` logical operator to check whether a value *equals*, or is equivalent, to some other value. This is different from the single `=` which is used to create entire new variables inside `mutate()`. \n\nHere is one more example using `case_when()`.\n\n\n::: {.cell hash='13_data_wrangling_cleaning_cache/html/unnamed-chunk-14_219bed2c3573d773e02e2bb514fff316'}\n\n```{.r .cell-code}\nun_votes |> \n  mutate(rcid_era = case_when(rcid < 2000 ~ \"old\",\n                              rcid >= 2000 & rcid < 6000 ~ \"middle\",\n                              rcid >= 6000 ~ \"recent\")) |> \n  head()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 5\n   rcid country            country_code vote  rcid_era\n  <dbl> <chr>              <chr>        <fct> <chr>   \n1     3 United States      US           yes   old     \n2     3 Canada             CA           no    old     \n3     3 Cuba               CU           yes   old     \n4     3 Haiti              HT           yes   old     \n5     3 Dominican Republic DO           yes   old     \n6     3 Mexico             MX           yes   old     \n```\n:::\n:::\n\n\n\nThe new variable \"rcid_era\" takes three values, `\"old\"`, `\"middle\"`, and `\"recent\"` based on what range the \"rcid\" variable falls within.\n\nTo recap, the most commonly used functions for cleaning columns/variables in your data are:\n\n  -   `select()` removes and/or renames columns.\n  -   `rename()` renames existing columns without removing any.\n  -   `mutate()` changes the values of existing columns and creates new columns.\n  \nThe new variable \"rcid_era\" takes three values, `\"old\"`, `\"middle\"`, and `\"recent\"` based on what range the \"rcid\" variable falls under.\n\n## Working with Rows\n\n### Filter\n\nDplyr's primary function for removing rows is `filter()`. Like we saw when using `case_when()` inside `mutate()`, using `filter()` requires some practice with logical operators. The function `filter()` works by specifying some variable and only keeping rows in the data for which the logical operation evaluates to `TRUE`. Here is an example.\n\n\n::: {.cell hash='13_data_wrangling_cleaning_cache/html/unnamed-chunk-15_d97f38668769a783ca2637db9fbdce36'}\n\n```{.r .cell-code}\nun_roll_calls |> \n  filter(importantvote == 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 411 × 9\n    rcid session importantvote date       unres     amend  para short      descr\n   <int>   <dbl>         <int> <date>     <chr>     <int> <int> <chr>      <chr>\n 1  2491      38             1 1983-10-04 R/38/3        0     0 KAMPUCHEA  TO R…\n 2  2492      38             1 1983-11-06 R/38/7        0     0 GRENADA, … TO D…\n 3  2497      38             1 1983-11-06 R/38/29       0     0 AFGHANIST… TO D…\n 4  2504      38             1 1983-12-06 R/38/39A      0     0 APARTHEID… TO A…\n 5  2510      38             1 1983-12-06 R/38/39G      0     0 SOUTH AFR… TO R…\n 6  2526      38             1 1983-12-06 R/38/180E     0     0 ISRAEL, I… TO O…\n 7  2563      38             1 1983-12-07 R/38/187C     0     0 CHEMICAL,… TO N…\n 8  2610      38             1 1983-12-03 R/38/101      0     0 HUMAN RIG… TO E…\n 9  2641      39             1 1984-10-04 R/39/5        0     0 KAMPUCHEA  TO R…\n10  2645      39             1 1984-11-02 R/39/13       0     0 AFGHANIST… TO R…\n# … with 401 more rows\n# ℹ Use `print(n = ...)` to see more rows\n```\n:::\n:::\n\n\nThe original \"un_roll_calls\" data set object has 6202 rows, whereas this new data set only has 411 rows. This is because we filtered out any row in which the variable \"importantvote\" was not equal to `1`. Like `select()`, we can extend the use of `filter()` in many ways.\n\n\n::: {.cell hash='13_data_wrangling_cleaning_cache/html/unnamed-chunk-16_ffa5986fa428efff5032c6d678d15d8d'}\n\n```{.r .cell-code}\n# & for AND\nun_roll_calls |> \n  filter(importantvote == 1 & session > 40)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 386 × 9\n    rcid session importantvote date       unres     amend  para short      descr\n   <int>   <dbl>         <int> <date>     <chr>     <int> <int> <chr>      <chr>\n 1  2948      41             1 1986-10-03 R/41/6       NA    NA KAMPUCHEA  The …\n 2  2957      41             1 1986-11-02 R/41/31      NA    NA NICARAGUA… Urge…\n 3  2958      41             1 1986-11-04 R/41/33      NA    NA AFGHANIST… The …\n 4  2967      41             1 1986-11-05 R/41/38      NA    NA LIBYA, U.… Decl…\n 5  2968      41             1 1986-11-05 R/41/39A     NA    NA NAMIBIA, … Situ…\n 6  2996      41             1 1986-12-04 R/41/58C     NA    NA CHEMICAL,… Proh…\n 7  3075      41             1 1986-12-05 R/41/158     NA    NA HUMAN RIG… Ques…\n 8  3078      41             1 1986-12-05 R/41/162A    NA    NA MIDDLE EA… Reaf…\n 9  3098      41             1 1986-12-05 R/41/211A    NA    NA BUDGET, 1… Revi…\n10  3099      41             1 1986-12-05 R/41/211B    NA    NA BUDGET, 1… Revi…\n# … with 376 more rows\n# ℹ Use `print(n = ...)` to see more rows\n```\n:::\n\n```{.r .cell-code}\n# | for OR\nun_roll_calls |> \n  filter(importantvote == 1 | session > 40)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3,228 × 9\n    rcid session importantvote date       unres     amend  para short      descr\n   <int>   <dbl>         <int> <date>     <chr>     <int> <int> <chr>      <chr>\n 1  2491      38             1 1983-10-04 R/38/3        0     0 KAMPUCHEA  TO R…\n 2  2492      38             1 1983-11-06 R/38/7        0     0 GRENADA, … TO D…\n 3  2497      38             1 1983-11-06 R/38/29       0     0 AFGHANIST… TO D…\n 4  2504      38             1 1983-12-06 R/38/39A      0     0 APARTHEID… TO A…\n 5  2510      38             1 1983-12-06 R/38/39G      0     0 SOUTH AFR… TO R…\n 6  2526      38             1 1983-12-06 R/38/180E     0     0 ISRAEL, I… TO O…\n 7  2563      38             1 1983-12-07 R/38/187C     0     0 CHEMICAL,… TO N…\n 8  2610      38             1 1983-12-03 R/38/101      0     0 HUMAN RIG… TO E…\n 9  2641      39             1 1984-10-04 R/39/5        0     0 KAMPUCHEA  TO R…\n10  2645      39             1 1984-11-02 R/39/13       0     0 AFGHANIST… TO R…\n# … with 3,218 more rows\n# ℹ Use `print(n = ...)` to see more rows\n```\n:::\n:::\n\n\nThe first chunk above filters out all rows in which \"importantvote\" did not equal `1` *AND* \"session\" was less than `40`. The second chunk above filters out all rows in which \"importantvote\" did not equal `1` *OR* \"session\" was less than `40`.\n\nRemoving missing, or `NA`, values is another common job for `filter()`. To do this you can use the function `is.na()` inside `filter()`. The function `is.na()` evaluates to `TRUE` if the variable's value is `NA` and evaluates to `FALSE` otherwise. Because `filter()` only keeps rows where the condition evaluates to `TRUE`, in order to *remove* `NA` values we need to negate `is.na()` with the `!` operator. The `!` operator flips the truthiness of any logical statement it precedes. \n\n\n::: {.cell hash='13_data_wrangling_cleaning_cache/html/unnamed-chunk-17_157fa43c3959c34111ad96d52dc2d3b8'}\n\n```{.r .cell-code}\nun_roll_calls |> \n  filter(!is.na(amend)) # Removing rows with NA for amend\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2,868 × 9\n    rcid session importantvote date       unres   amend  para short        descr\n   <int>   <dbl>         <int> <date>     <chr>   <int> <int> <chr>        <chr>\n 1     3       1             0 1946-01-01 R/1/66      1     0 AMENDMENTS,… \"TO …\n 2     4       1             0 1946-01-02 R/1/79      0     0 SECURITY CO… \"TO …\n 3     5       1             0 1946-01-04 R/1/98      0     0 VOTING PROC… \"TO …\n 4     6       1             0 1946-01-04 R/1/107     0     0 DECLARATION… \"TO …\n 5     7       1             0 1946-01-02 R/1/295     1     0 GENERAL ASS… \"TO …\n 6     8       1             0 1946-01-05 R/1/297     1     0 ECOSOC POWE… \"TO …\n 7     9       1             0 1946-02-05 R/1/329     0     0 POST-WAR RE… \"TO …\n 8    10       1             0 1946-02-05 R/1/361     1     1 U.N. MEMBER… \"TO …\n 9    11       1             0 1946-02-05 R/1/376     0     0 TRUSTEESHIP… \"TO …\n10    12       1             0 1946-02-06 R/1/394     1     1 COUNCIL MEM… \"TO …\n# … with 2,858 more rows\n# ℹ Use `print(n = ...)` to see more rows\n```\n:::\n:::\n\n\nIt can be confusing to think in terms of logical statements, especially when negation is involved! But you will become more comfortable with `filter()` the more you practice!\n\nAnother handy logical operator is `%in%`. This lets you specify several values at once when checking whether to keep rows in `filter()`. \n\n\n::: {.cell hash='13_data_wrangling_cleaning_cache/html/unnamed-chunk-18_2fd7c86236e8e37f6ee827cad3699c78'}\n\n```{.r .cell-code}\n# Cumbersome way\nun_votes |> \n  filter(country == \"Kenya\" |\n         country == \"Grenada\" |\n         country == \"Canada\" |\n         country == \"Latvia\" |\n         country == \"Yemen\" |\n         country == \"Angola\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 23,324 × 4\n    rcid country country_code vote \n   <dbl> <chr>   <chr>        <fct>\n 1     3 Canada  CA           no   \n 2     4 Canada  CA           no   \n 3     5 Canada  CA           no   \n 4     6 Canada  CA           no   \n 5     7 Canada  CA           no   \n 6     8 Canada  CA           yes  \n 7     9 Canada  CA           yes  \n 8    10 Canada  CA           yes  \n 9    11 Canada  CA           yes  \n10    12 Canada  CA           yes  \n# … with 23,314 more rows\n# ℹ Use `print(n = ...)` to see more rows\n```\n:::\n\n```{.r .cell-code}\n# Easier way\ncountry_list <- c(\"Kenya\", \"Grenada\", \"Canada\",\n                  \"Latvia\", \"Yemen\", \"Angola\")\nun_votes |> \n  filter(country %in% country_list)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 23,324 × 4\n    rcid country country_code vote \n   <dbl> <chr>   <chr>        <fct>\n 1     3 Canada  CA           no   \n 2     4 Canada  CA           no   \n 3     5 Canada  CA           no   \n 4     6 Canada  CA           no   \n 5     7 Canada  CA           no   \n 6     8 Canada  CA           yes  \n 7     9 Canada  CA           yes  \n 8    10 Canada  CA           yes  \n 9    11 Canada  CA           yes  \n10    12 Canada  CA           yes  \n# … with 23,314 more rows\n# ℹ Use `print(n = ...)` to see more rows\n```\n:::\n:::\n\n\nThe two chunks of code above will produce the same filtered data set, but the second chunk requires fewer lines of code and is more flexible if we want to add or remove countries.\n\n### Aggregation\n\nFiltering is great for removing unwanted rows in your data. However, after using `filter()` the unit of analysis typically remains the same. In the code chunk above, for example, we removed most of the countries from our data, but each row in the resulting data set is still a unique country-vote observation. \n\nLet's say we want to reduce the data set down to the country level, rather than country-vote level, and examine the proportion of \"no\" votes taken by each country. We can do this in dplyr using the pair of functions `group_by()` and `summarize()`. Here is an example.\n\n\n::: {.cell hash='13_data_wrangling_cleaning_cache/html/unnamed-chunk-19_32f3e0c81d13e8b29a665a915cb59694'}\n\n```{.r .cell-code}\nun_votes |> \n  # Creating a new numeric dummy vote variable\n  mutate(vote_dummy = case_when(vote == \"yes\" ~ 1,\n                                vote == \"no\" ~ 0)) |> \n  # Specify level of aggregation\n  group_by(country) |> \n  # Perform the aggregation function by group\n  summarize(proportion_yes_vote = mean(vote_dummy, na.rm = TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 200 × 2\n   country           proportion_yes_vote\n   <chr>                           <dbl>\n 1 Afghanistan                     0.938\n 2 Albania                         0.816\n 3 Algeria                         0.965\n 4 Andorra                         0.833\n 5 Angola                          0.985\n 6 Antigua & Barbuda               0.988\n 7 Argentina                       0.935\n 8 Armenia                         0.950\n 9 Australia                       0.745\n10 Austria                         0.880\n# … with 190 more rows\n# ℹ Use `print(n = ...)` to see more rows\n```\n:::\n:::\n\n\nThe code above uses the function `mean()` to calculate the average value of \"vote_dummy\" within each country. Because \"vote_dummy\" takes the values `1` and `0`, this average can be interpreted as a proportion of 1's, or \"yes\" votes. We need to add `na.rm = TRUE` inside `mean()` to tell R to ignore `NA` values when calculating this average.\n\nIf we want to sort our data by the new aggregated column, we can do so using `arrange()` after `summarize()`.\n\n\n::: {.cell hash='13_data_wrangling_cleaning_cache/html/unnamed-chunk-20_5ec2ba40801444c7b34e213d52328822'}\n\n```{.r .cell-code}\nun_votes |> \n  mutate(vote_dummy = case_when(vote == \"yes\" ~ 1,\n                                vote == \"no\" ~ 0)) |> \n  group_by(country) |> \n  summarize(proportion_yes_vote = mean(vote_dummy, na.rm = TRUE)) |> \n  arrange(proportion_yes_vote)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 200 × 2\n   country                          proportion_yes_vote\n   <chr>                                          <dbl>\n 1 United States                                  0.369\n 2 Israel                                         0.464\n 3 Palau                                          0.541\n 4 Micronesia (Federated States of)               0.604\n 5 United Kingdom                                 0.616\n 6 Marshall Islands                               0.659\n 7 France                                         0.662\n 8 Federal Republic of Germany                    0.682\n 9 Canada                                         0.701\n10 Belgium                                        0.714\n# … with 190 more rows\n# ℹ Use `print(n = ...)` to see more rows\n```\n:::\n\n```{.r .cell-code}\n# Use arrange(desc(proportion_yes_vote))\n# to sort in descending order\n```\n:::\n\n\nThe United States votes \"No\" at a much higher rate than other countries!\n\n\n::: {.cell hash='13_data_wrangling_cleaning_cache/html/unnamed-chunk-21_8e3148c22d78763dfcaed01b9ef89569'}\n\n```{.r .cell-code}\nun_roll_call_issues |> \n  count(issue)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 2\n  issue                                    n\n  <fct>                                <int>\n1 Colonialism                            957\n2 Arms control and disarmament          1092\n3 Economic development                   765\n4 Human rights                          1015\n5 Palestinian conflict                  1061\n6 Nuclear weapons and nuclear material   855\n```\n:::\n:::\n\n\n\n\n## Merging Data\n\nSo far we have only been working with one data set at a time.\n\n\n::: {.cell hash='13_data_wrangling_cleaning_cache/html/unnamed-chunk-22_dcc27034ab9fd9d3d44e1ab2b0586447'}\n\n```{.r .cell-code}\nun_votes |> \n  left_join(un_roll_calls, by = \"rcid\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 869,937 × 12\n    rcid country      count…¹ vote  session impor…² date       unres amend  para\n   <dbl> <chr>        <chr>   <fct>   <dbl>   <int> <date>     <chr> <int> <int>\n 1     3 United Stat… US      yes         1       0 1946-01-01 R/1/…     1     0\n 2     3 Canada       CA      no          1       0 1946-01-01 R/1/…     1     0\n 3     3 Cuba         CU      yes         1       0 1946-01-01 R/1/…     1     0\n 4     3 Haiti        HT      yes         1       0 1946-01-01 R/1/…     1     0\n 5     3 Dominican R… DO      yes         1       0 1946-01-01 R/1/…     1     0\n 6     3 Mexico       MX      yes         1       0 1946-01-01 R/1/…     1     0\n 7     3 Guatemala    GT      yes         1       0 1946-01-01 R/1/…     1     0\n 8     3 Honduras     HN      yes         1       0 1946-01-01 R/1/…     1     0\n 9     3 El Salvador  SV      yes         1       0 1946-01-01 R/1/…     1     0\n10     3 Nicaragua    NI      yes         1       0 1946-01-01 R/1/…     1     0\n# … with 869,927 more rows, 2 more variables: short <chr>, descr <chr>, and\n#   abbreviated variable names ¹​country_code, ²​importantvote\n# ℹ Use `print(n = ...)` to see more rows, and `colnames()` to see all variable names\n```\n:::\n:::\n\n::: {.cell hash='13_data_wrangling_cleaning_cache/html/unnamed-chunk-23_35ee867fa2b62de6e2069eb79ba87c4f'}\n\n```{.r .cell-code}\nun_votes |> \n  left_join(un_roll_call_issues, by = \"rcid\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1,123,334 × 6\n    rcid country            country_code vote  short_name issue\n   <dbl> <chr>              <chr>        <fct> <chr>      <fct>\n 1     3 United States      US           yes   <NA>       <NA> \n 2     3 Canada             CA           no    <NA>       <NA> \n 3     3 Cuba               CU           yes   <NA>       <NA> \n 4     3 Haiti              HT           yes   <NA>       <NA> \n 5     3 Dominican Republic DO           yes   <NA>       <NA> \n 6     3 Mexico             MX           yes   <NA>       <NA> \n 7     3 Guatemala          GT           yes   <NA>       <NA> \n 8     3 Honduras           HN           yes   <NA>       <NA> \n 9     3 El Salvador        SV           yes   <NA>       <NA> \n10     3 Nicaragua          NI           yes   <NA>       <NA> \n# … with 1,123,324 more rows\n# ℹ Use `print(n = ...)` to see more rows\n```\n:::\n:::\n\n::: {.cell hash='13_data_wrangling_cleaning_cache/html/unnamed-chunk-24_3976f66fec3934a852b2bf25401ff39c'}\n\n```{.r .cell-code}\nun_roll_calls |> \n  left_join(un_roll_call_issues)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nJoining, by = \"rcid\"\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 7,848 × 11\n    rcid session import…¹ date       unres amend  para short descr short…² issue\n   <int>   <dbl>    <int> <date>     <chr> <int> <int> <chr> <chr> <chr>   <fct>\n 1     3       1        0 1946-01-01 R/1/…     1     0 AMEN… \"TO … <NA>    <NA> \n 2     4       1        0 1946-01-02 R/1/…     0     0 SECU… \"TO … <NA>    <NA> \n 3     5       1        0 1946-01-04 R/1/…     0     0 VOTI… \"TO … <NA>    <NA> \n 4     6       1        0 1946-01-04 R/1/…     0     0 DECL… \"TO … hr      Huma…\n 5     7       1        0 1946-01-02 R/1/…     1     0 GENE… \"TO … <NA>    <NA> \n 6     8       1        0 1946-01-05 R/1/…     1     0 ECOS… \"TO … ec      Econ…\n 7     9       1        0 1946-02-05 R/1/…     0     0 POST… \"TO … <NA>    <NA> \n 8    10       1        0 1946-02-05 R/1/…     1     1 U.N.… \"TO … <NA>    <NA> \n 9    11       1        0 1946-02-05 R/1/…     0     0 TRUS… \"TO … co      Colo…\n10    11       1        0 1946-02-05 R/1/…     0     0 TRUS… \"TO … ec      Econ…\n# … with 7,838 more rows, and abbreviated variable names ¹​importantvote,\n#   ²​short_name\n# ℹ Use `print(n = ...)` to see more rows\n```\n:::\n:::\n\n\n\n## Reshaping Data\n\n\n::: {.cell hash='13_data_wrangling_cleaning_cache/html/unnamed-chunk-25_c3143e56fc8665a32e94200420fce27f'}\n\n```{.r .cell-code}\nwide_un_votes <- un_votes |> \n  pivot_wider(id_cols = rcid,\n              values_from = vote,\n              names_from = country)\n\nhead(wide_un_votes)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 201\n   rcid United State…¹ Canada Cuba  Haiti Domin…² Mexico Guate…³ Hondu…⁴ El Sa…⁵\n  <dbl> <fct>          <fct>  <fct> <fct> <fct>   <fct>  <fct>   <fct>   <fct>  \n1     3 yes            no     yes   yes   yes     yes    yes     yes     yes    \n2     4 no             no     no    no    no      no     no      no      no     \n3     5 no             no     yes   no    no      yes    no      yes     yes    \n4     6 no             no     yes   <NA>  abstain yes    no      yes     abstain\n5     7 no             no     yes   yes   yes     yes    <NA>    yes     <NA>   \n6     8 no             yes    yes   <NA>  yes     yes    yes     <NA>    <NA>   \n# … with 191 more variables: Nicaragua <fct>, `Costa Rica` <fct>, Panama <fct>,\n#   Colombia <fct>, Venezuela <fct>, Ecuador <fct>, Peru <fct>, Brazil <fct>,\n#   Bolivia <fct>, Paraguay <fct>, Chile <fct>, Argentina <fct>, Uruguay <fct>,\n#   `United Kingdom` <fct>, Netherlands <fct>, Belgium <fct>, Luxembourg <fct>,\n#   France <fct>, Poland <fct>, Czechoslovakia <fct>, Yugoslavia <fct>,\n#   Greece <fct>, Russia <fct>, Ukraine <fct>, Belarus <fct>, Norway <fct>,\n#   Denmark <fct>, Liberia <fct>, Ethiopia <fct>, `South Africa` <fct>, …\n# ℹ Use `colnames()` to see all variable names\n```\n:::\n:::\n\n::: {.cell hash='13_data_wrangling_cleaning_cache/html/unnamed-chunk-26_66fbbf859f3b6e076a164016c20da1bb'}\n\n```{.r .cell-code}\nlong_un_votes <- wide_un_votes |> \n  pivot_longer(cols = -rcid,\n               names_to = \"country\",\n               values_to = \"vote\")\n\nlong_un_votes\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1,240,400 × 3\n    rcid country            vote \n   <dbl> <chr>              <fct>\n 1     3 United States      yes  \n 2     3 Canada             no   \n 3     3 Cuba               yes  \n 4     3 Haiti              yes  \n 5     3 Dominican Republic yes  \n 6     3 Mexico             yes  \n 7     3 Guatemala          yes  \n 8     3 Honduras           yes  \n 9     3 El Salvador        yes  \n10     3 Nicaragua          yes  \n# … with 1,240,390 more rows\n# ℹ Use `print(n = ...)` to see more rows\n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}