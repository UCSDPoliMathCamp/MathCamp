{
  "hash": "974a6c45050910f4ff2ee4d197b69a6c",
  "result": {
    "markdown": "\n# Visualization {#dataviz}\n\nThis lesson is about creating effective data visualizations using the [ggplot2](https://ggplot2.tidyverse.org/) package (part of the Tidyverse). Becoming good at graphing your data is a key skill you will want to develop while in the PhD program. Each graph you make should clearly communicate an insight without overloading your audience with too much information. Today we will practice the nuts and bolts of the coding necessary to accomplish this.\n\nLet's start by loading in our external packages: the Tidyverse, and here.\n\n\n::: {.cell hash='12_visualization_cache/html/unnamed-chunk-1_c5026f7b75b84299833f27b976ecf972'}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(here)\n```\n:::\n\n\nWe will load in the same \"county_elections.csv\" data set from the previous chapter. Note: we will also remove each row in the data set containing missing values so that we avoid being spammed with warning messages from R. In a real data analysis project, you will want to investigate the source of missing data rather than blanket-removing everything.\n\n\n::: {.cell hash='12_visualization_cache/html/unnamed-chunk-2_5f3225408c00c54cf1637258f4c1a887'}\n\n```{.r .cell-code}\ncounty_elections <- read_csv(here(\"data\", \"county_elections.csv\"))\n\n# Remove any rows with missing values to avoid warning messages\ncounty_elections <- na.omit(county_elections)\n```\n:::\n\n\n## Univariate Graphs\n\nThe first graph we will make is a histogram. Histograms are the most common type of graph for continuous variables and make it easy to see the spread and central tendency of the data. Let's plot the distribution of county median household income using the variable `median_hh_inc` in `county_elections`.\n\n\n::: {.cell hash='12_visualization_cache/html/unnamed-chunk-3_effbd48350c72658ec24dbb2ba3d0374'}\n\n```{.r .cell-code}\nggplot(county_elections) +\n  aes(x = median_hh_inc) +\n  geom_histogram()\n```\n\n::: {.cell-output-display}\n![](12_visualization_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\nEach graph you create using ggplot will contain the following three elements\n\n  1. **Data**. You need to tell ggplot which data set the variables that you want to graph come from. This section is `ggplot(county_elections)` in the code above.\n  2. **Aesthetics**. Now that we know which data set we're working with, which variables do you want to use and in what way do we want them to be used? This information goes in the `aes()` section. Because histograms typically view the distribution of a single variable along the x-axis of a graph, we specify our aesthetic `aes(x = median_hh_inc)` in the code above.\n  3. **Geoms**. The \"geom\" we choose defines the type of graph we're ultimately creating (histogram, scatter plot, bar graph, etc). As you might expect, `geom_histogram()` creates a histogram for us! \n  \nIn ggplot we combine these elements together using the `+` symbol. You could put the data, aesthetics, and geom sections all in the same line of code. But it is good practice to put each on its own line to make your code more readable. \n\nEach geom in ggplot has tons of extra options (also called arguments), which you can specify to make your graphs more pretty. Let's begin to customize our histogram!\n\n\n::: {.cell hash='12_visualization_cache/html/unnamed-chunk-4_094cdd65955c2ccf09fa90cd2f68f154'}\n\n```{.r .cell-code}\nggplot(county_elections) +\n  aes(x = median_hh_inc) +\n  geom_histogram(bins = 50,\n                 color = \"white\",\n                 fill = \"steelblue\")\n```\n\n::: {.cell-output-display}\n![](12_visualization_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\nWow look at that! Now let's fix the ugly default names on the x and y axes, and add an informative title for our graph. We add custom labels to a ggplot graph by adding another `+` followed by a `labs()` section.\n\n\n::: {.cell hash='12_visualization_cache/html/unnamed-chunk-5_aa64866b53b70387c2ecc26fff833ca6'}\n\n```{.r .cell-code}\nggplot(county_elections) +\n  aes(x = median_hh_inc) +\n  geom_histogram(bins = 50,\n                 color = \"white\",\n                 fill = \"steelblue\") +\n  labs(title = \"Distribution of Median County Incomes\",\n       x = \"Median Household Income\",\n       y = \"Count\")\n```\n\n::: {.cell-output-display}\n![](12_visualization_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\nThemes in ggplot control the overall look and background style of our graphs. For a complete list of themes: [Link](https://ggplot2.tidyverse.org/reference/ggtheme.html). There is also a package with a bunch of additional cool themes you can check out here: [Link](https://yutannihilation.github.io/allYourFigureAreBelongToUs/ggthemes/). Personally I'm a big fan of `theme_minimal()`. \n\n\n::: {.cell hash='12_visualization_cache/html/unnamed-chunk-6_ead47d147c79ede956e5a69bf3e60e0b'}\n\n```{.r .cell-code}\nggplot(county_elections) +\n  aes(x = median_hh_inc) +\n  geom_histogram(bins = 50,\n                 color = \"white\",\n                 fill = \"steelblue\") +\n  labs(title = \"Distribution of Median County Incomes\",\n       x = \"Median Household Income\",\n       y = \"Count\") +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](12_visualization_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\nOur county median household income variable looks like it's a bit right-skewed---with a few extremely high income counties shown on the right hand side of the graph. Depending on your research question, it might make more sense to view this distribution on the log scale. It's very easy to do this in ggplot using `scale_x_log10()`.\n\n\n::: {.cell hash='12_visualization_cache/html/unnamed-chunk-7_0f204674c3b0159133f63efcbcdbe1c4'}\n\n```{.r .cell-code}\nggplot(county_elections) +\n  aes(x = median_hh_inc) +\n  geom_histogram(bins = 50,\n                 color = \"white\",\n                 fill = \"steelblue\") +\n  labs(title = \"Distribution of Median County Incomes\",\n       x = \"Median Household Income\",\n       y = \"\",\n       caption = \"(log10 scale)\") +\n  theme_minimal() +\n  scale_x_log10(labels = scales::dollar)\n```\n\n::: {.cell-output-display}\n![](12_visualization_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\nNow the data looks almost normally distributed. Also note the use of `scales::dollar` to make our x-axis a little easier to read. The [scales package](https://scales.r-lib.org/) provides a ton of handy functions to deal with ugly default scales in ggplot. The `::` operator is a way of accessing a single function from a package without loading all its other functions into R. It's also a way of being explicit about which package's function you are using. Sometimes you will run across situations where multiple packages have functions with the same name, but which do different things! Speaking from personal experience, this can lead to some really frustrating debugging sessions.\n\n<!-- Class activity - univariate graphs -->\n<!-- Choose another univariate geom and variable and graph it -->\n\n## Bivariate Graphs\n\nIf histograms are the most common way to plot the distribution of a single continuous variable, scatter plots are the most common way to show the relationship between two continuous variables. Translating our histogram ggplot code to a scatter plot is straightforward: simply add a y-axis variable to `aes()`, and change the geom to `geom_point()`. The graph below displays the relationship between median household income and the population percentage in a county who did not complete high school. \n\n\n::: {.cell hash='12_visualization_cache/html/unnamed-chunk-8_aa441f76bad0322f8f598cf8f59cd051'}\n\n```{.r .cell-code}\nggplot(county_elections) +\n  aes(x = median_hh_inc, y = lesshs_pct) +\n  geom_point()\n```\n\n::: {.cell-output-display}\n![](12_visualization_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\nIt looks like richer counties have lower rates of their population having less than a high school education. We can use the same customization options from histograms on our scatter plot to make things prettier.\n\n\n::: {.cell hash='12_visualization_cache/html/unnamed-chunk-9_24cc3229c578e0966260156644159cbe'}\n\n```{.r .cell-code}\nggplot(county_elections) +\n  aes(x = median_hh_inc, y = lesshs_pct) +\n  geom_point() +\n  labs(title = \"US Counties by Education and Income\",\n       x = \"Median Household Income\",\n       y = \"Less than High School %\") +\n  scale_x_continuous(label = scales::dollar) +\n  theme_classic()\n```\n\n::: {.cell-output-display}\n![](12_visualization_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\nA lot of our data seems to be clustered up together. The solid points in `geom_point()` obscure this density so let's fix this using the `alpha` argument. A geom's `alpha` level specifies its transparency and ranges from 1 (solid) to 0 (invisible). \n\n\n::: {.cell hash='12_visualization_cache/html/unnamed-chunk-10_100a9ed48e6e42a641b8ccd83765c0f4'}\n\n```{.r .cell-code}\nggplot(county_elections) +\n  aes(x = median_hh_inc, y = lesshs_pct) +\n  geom_point(alpha = 0.2, color = \"darkcyan\") +\n  labs(title = \"US Counties by Education and Income\",\n       x = \"Median Household Income\",\n       y = \"Less than High School %\") +\n  scale_x_continuous(label = scales::dollar) +\n  theme_classic()\n```\n\n::: {.cell-output-display}\n![](12_visualization_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\nThe negative relationship between our two variables is clear just by eyeballing it, but if we want to be real scientists we need to add the magic regression line. If you are unfamiliar with regression lines, don't worry---we will be covering them extensively in your introductory quantitative methods course. A linear regression line is essentially just the \"best fitting\" straight line to the data.\n\nAdding a regression line to the graph gives us our first opportunity to combine multiple *geoms*. In the code chunk below, notice how we simply use `+` to add `geom_smooth()` to our ggplot object. This overlays a fitted line on top of the dots from `geom_point()`. The argument `method = \"lm\"` tells ggplot to use a linear regression line (`lm` = \"linear model\") as opposed to some other type of fitted line.\n\n\n::: {.cell hash='12_visualization_cache/html/unnamed-chunk-11_de3855c32a36a986ba7f9539e4c140f4'}\n\n```{.r .cell-code}\nggplot(county_elections) +\n  aes(x = median_hh_inc, y = lesshs_pct) +\n  geom_point(alpha = 0.2, color = \"darkcyan\") +\n  geom_smooth(method = \"lm\", color = \"black\") +\n  labs(title = \"US Counties by Education and Income\",\n       x = \"Median Household Income\",\n       y = \"Less than High School %\") +\n  scale_x_continuous(label = scales::dollar) +\n  theme_classic()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`geom_smooth()` using formula 'y ~ x'\n```\n:::\n\n::: {.cell-output-display}\n![](12_visualization_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n\nThis graph would look way more professional if it didn't mistakenly predict negative high school percentage values for high income counties. Linear regression is clearly not flexible enough to reflect the true relationship between our two variables. \n\nWhat if we re-scaled median household income to the log10 scale again?\n\n\n::: {.cell hash='12_visualization_cache/html/unnamed-chunk-12_ad121c36ebb4935e2ba20f08fca5a2ee'}\n\n```{.r .cell-code}\nggplot(county_elections) +\n  aes(x = median_hh_inc, y = lesshs_pct) +\n  geom_point(alpha = 0.2, color = \"darkcyan\") +\n  geom_smooth(method = \"lm\", color = \"black\",\n              formula = \"y ~ log(x)\") +\n  labs(title = \"US Counties by Education and Income\",\n       x = \"Median Household Income\",\n       y = \"Less than High School %\") +\n  scale_x_continuous(label = scales::dollar) +\n  theme_classic()\n```\n\n::: {.cell-output-display}\n![](12_visualization_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n:::\n\n\nNot perfect, but now our fitted line is looking better!\n\n<!-- Class Activity - bivariate graph -->\n<!-- - Make a 2d bin graph -->\n\n## Trivariate(!) Graphs\n\nWe are now experts are graphing one variable at a time, or two variables together, but what if we want to graph three or more variables at once? There are a number of ways to do this in ggplot as we will see below. However, first a word of caution: beware of cluttering your plots with *too* much information! It can be tempting to throw everything into a graph, but doing so can obscure the main point you're trying to make. Always keep this in mind when going beyond graphing two variables at once.\n\n### Using Colors and Shapes\n\nThe `county_elections` data set does not have a lot of categorical variables for us to work with. So let's create one!\n\n\n::: {.cell hash='12_visualization_cache/html/unnamed-chunk-13_50e8eb3b01e2973cde08c40a2c82c591'}\n\n```{.r .cell-code}\ncounty_elections <- county_elections |> \n  mutate(rural = ifelse(rural_pct > 50, \"Rural\", \"Not Rural\"))\n```\n:::\n\n\nThis code chunk uses the `mutate` function to create a new variable in the `county_elections` data set called `rural`. The variable `rural` takes the value \"Rural\" if `rural_pct` is greater than 50 and takes the value \"Not Rural\" if `rural_pct` is less than or equal to 50. It is usually not a good idea to dichotomize a continuous variable in this way (using a binary Rural/Not Rural as opposed to the county's rural percentage). Doing so throws away valuable information that is almost always relevant to the final analysis. In this case we can justify our choice to create a categorical variable because it will make plotting multiple variables much easier.\n\nLet's now take our scatter plot showing the relationship between county median household income and education level, and color the points based on whether the county is rural or not. Doing so is as easy as adding `color = rural` to the `aes()` section in ggplot.\n\n\n::: {.cell hash='12_visualization_cache/html/unnamed-chunk-14_b993172719be9a7b56259a75b8c4a95a'}\n\n```{.r .cell-code}\nggplot(county_elections) +\n  aes(x = median_hh_inc, y = lesshs_pct,\n      color = rural) + # Coloring points based on rural variable\n  geom_point(alpha = 0.5) + # Removed color from geom\n  labs(title = \"US Counties by Education and Income\",\n       x = \"Median Household Income\",\n       y = \"Less than High School %\") +\n  scale_x_continuous(label = scales::dollar) +\n  theme_classic()\n```\n\n::: {.cell-output-display}\n![](12_visualization_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n:::\n\n\nBy default, ggplot even gives us a handy legend to tell us which color points correspond to which value of `rural`. \n\nNow let's try adding a third variable to our scatter plot which is continuous. One way to do this is with the `size` option in `aes()`.\n\n\n::: {.cell hash='12_visualization_cache/html/unnamed-chunk-15_eeebdcab477ee6ffaa25925d5c66fc70'}\n\n```{.r .cell-code}\nggplot(county_elections) +\n  aes(x = median_hh_inc, y = lesshs_pct,\n      size = total_population) + # Changing size of points\n  geom_point(alpha = 0.2) + \n  labs(title = \"US Counties by Education and Income\",\n       x = \"Median Household Income\",\n       y = \"Less than High School %\") +\n  scale_x_continuous(label = scales::dollar) +\n  theme_classic()\n```\n\n::: {.cell-output-display}\n![](12_visualization_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n:::\n\n\nAre we overdoing things with adding too much information to our graph? Possibly!\n\n### Using Facets to Graph Comparisons\n\nOne of ggplot's most powerful features is \"faceting\". Facets allow you to easily graph comparisons between different levels of a categorical variable in a clear manner by creating side by side subgraphs. To apply a facet to our ggplot graph we can simply add `+ facet_wrap(~ facet_variable)`.\n\n\n::: {.cell hash='12_visualization_cache/html/unnamed-chunk-16_de5d10822d681b60a0b780a2890e85ab'}\n\n```{.r .cell-code}\nggplot(county_elections) +\n  aes(x = median_hh_inc, y = lesshs_pct) +\n  geom_point(alpha = 0.2, color = \"darkcyan\") +\n  labs(title = \"US Counties by Education and Income\",\n       x = \"Median Household Income\",\n       y = \"Less than High School %\") +\n  scale_x_continuous(label = scales::dollar) +\n  theme_classic() +\n  facet_wrap(~ rural) # Adding faceting\n```\n\n::: {.cell-output-display}\n![](12_visualization_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n:::\n\n\nAs you can see, faceting is so powerful for showing comparisons because it preserves the scale in each subplot. This might be a better choice rather than coloring each point and overlapping everything. We can control whether we want the subgraphs side-by-side or on top of each other with the `nrow` argument.\n\n\n::: {.cell hash='12_visualization_cache/html/unnamed-chunk-17_32e1596ea57f5f277d6efa3295da07e0'}\n\n```{.r .cell-code}\nggplot(county_elections) +\n  aes(x = median_hh_inc, y = lesshs_pct) +\n  geom_point(alpha = 0.2, color = \"darkcyan\") +\n  labs(title = \"US Counties by Education and Income\",\n       x = \"Median Household Income\",\n       y = \"Less than High School %\") +\n  scale_x_continuous(label = scales::dollar) +\n  theme_classic() +\n  facet_wrap(~ rural, nrow = 2)\n```\n\n::: {.cell-output-display}\n![](12_visualization_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n:::\n\n\n\n\n## Choropleth Maps\n\nMaking maps in ggplot is relatively straightforward---and a much better idea than copying and pasting your data back and forth between R and a specialized program like ArcGIS. Choropleth maps show data broken down by geographic unit (in this case US counties). We will need to install an additional package [urbnmapr](https://urban-institute.medium.com/how-to-create-state-and-county-maps-easily-in-r-577d29300bb2) to help ggplot make this type of graph. To install urbnmapr, run the following command in your Console.\n\n\n::: {.cell hash='12_visualization_cache/html/unnamed-chunk-18_f0d54ff234d20c7fd0ea6645c41a07ff'}\n\n```{.r .cell-code}\ndevtools::install_github(\"UrbanInstitute/urbnmapr\")\n```\n:::\n\n\nWe use the command `devtools::install_github()` because the developers of urbnmapr have not submitted their package to the official CRAN repository. So rather than using `install.packages` like we're used to, we instead need to install the package directly from GitHub. A lot of excellent packages are not available on CRAN, but be aware that they might not have all the quality-control checks CRAN packages have.\n\nOnce you have the urbnmapr package installed, you can load it into R using:\n\n\n::: {.cell hash='12_visualization_cache/html/unnamed-chunk-19_30dad1eac4c632a7c12169b7669d6c00'}\n\n```{.r .cell-code}\nlibrary(urbnmapr)\n```\n:::\n\n\nWe need to perform a couple data cleaning steps before the data is ready to map in ggplot. The first step is making our `countyCode` variable match the format of the corresponding US county code in the urbnmapr data. US counties are each given a unique 5-digit number called a [FIPS code](https://www.nrcs.usda.gov/wps/portal/nrcs/detail/national/home/?cid=nrcs143_013697). However, at some point the \"county_elections.csv\" file was opened in Excel, which read the FIPS codes as numeric values thereby removing any 0's from the start of each code. Never open your data in Excel! Now a bunch of the FIPS codes in our data are only 4-digits long instead of 5, which means they will not match the FIPS codes in the urbnmapr data. Luckily we can fix this using the Tidyverse. The function `str_pad` from the [stringr](https://stringr.tidyverse.org/) package can be used to \"pad\" out a variable with a specific character until it becomes a specific size.\n\n\n::: {.cell hash='12_visualization_cache/html/unnamed-chunk-20_c3d543d4ef6d7c48449a656c90b8d9ac'}\n\n```{.r .cell-code}\ncounty_elections <- county_elections |> \n  mutate(county_fips = str_pad(countyCode, width = 5, pad = \"0\"))\n```\n:::\n\n\nNext we need to join our `county_elections` data with the mapping data from urbnmapr. We will do this using a `left_join` command, which, if you are not familiar with, we will cover in much greater detail in a future lesson. The big idea here is that we have one data set with county-level variables, such as median household income, that we need to merge with a data set containing the geographic coordinate information for each US county.\n\n\n::: {.cell hash='12_visualization_cache/html/unnamed-chunk-21_3fd8bb813c6b28e277e0d3388cb02cb3'}\n\n```{.r .cell-code}\nmap_data <- left_join(county_elections, counties)\n```\n:::\n\n\nAwesome! Now we are ready to make a map! Let's check out the geographic distribution of population percentage without a high school diploma.\n\n\n::: {.cell hash='12_visualization_cache/html/unnamed-chunk-22_792090d7e2ac38177df579372f5f091e'}\n\n```{.r .cell-code}\nggplot(map_data) +\n  aes(x = long, y = lat, \n      group = group, fill = lesshs_pct) +\n  geom_polygon(color = NA) +\n  # This second geom_polygon shows the state borders\n  geom_polygon(data = states, mapping = aes(long, lat, group = group),\n               fill = NA, size = 0.1, color = \"white\") +\n  # Making maps requires you to choose a geographic projection\n  coord_map(projection = \"albers\", lat0 = 39, lat1 = 45) +\n  # theme_void gives us a blank canvas\n  theme_void()\n```\n:::\n\n\nDon't worry if you are not yet able to understand every aspect of the ggplot code that produced this map. Try playing around with some of the arguments and see what happens to the map!\n\n\n::: {.cell hash='12_visualization_cache/html/unnamed-chunk-23_5553c97d832bb120688e0033954cdd94'}\n\n```{.r .cell-code}\nggplot(map_data) +\n  aes(x = long, y = lat, \n      group = group, fill = lesshs_pct) +\n  geom_polygon(color = NA) +\n  geom_polygon(data = states, mapping = aes(long, lat, group = group),\n               fill = NA, size = 0.1, color = \"white\") +\n  coord_map(projection = \"albers\", lat0 = 39, lat1 = 45) +\n  # This creates a diverging color scale\n  # that is also colorblind friendly\n  scale_fill_viridis_c() +\n  labs(fill = \"Less than High School %\") +\n  theme_void() +\n  theme(legend.position = \"bottom\") \n```\n:::\n\n\nSometimes a diverging color scale is better for contrasting high and low value areas.\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}